["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$hickory.hiccup-utils","~:imports",null,"~:requires",["^ ","~$str","~$clojure.string","^:","^:"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$class-names",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","~:line",83,"~:column",7,"~:end-line",83,"~:end-column",18,"~:arglists",["~#list",["~$quote",["^G",[["~$tag-elem"]]]]],"~:doc","Given a well-formed hiccup tag element, return a vector containing\n   any class names included in the tag, as strings. Ignores the hiccup\n   requirement that any id on the tag must come\n   first. Example: :div.foo.bar => [\"foo\" \"bar\"]."],"^5","~$hickory.hiccup-utils/class-names","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^E",18,"~:method-params",["^G",[["^I"]]],"~:protocol-impl",null,"~:arglists-meta",["^G",[null,null]],"^C",1,"~:variadic?",false,"^B",83,"~:ret-tag","~$clj","^D",83,"~:max-fixed-arity",1,"~:fn-var",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Given a well-formed hiccup tag element, return a vector containing\n   any class names included in the tag, as strings. Ignores the hiccup\n   requirement that any id on the tag must come\n   first. Example: :div.foo.bar => [\"foo\" \"bar\"]."],"~$tag-well-formed?",["^ ","^?",null,"^@",["^ ","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^B",38,"^C",7,"^D",38,"^E",23,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Given a hiccup tag element, returns true iff the tag is in 'valid' hiccup\n   format. Which in this function means:\n      1. Tag name is non-empty.\n      2. If there is an id, there is only one.\n      3. If there is an id, it is nonempty.\n      4. If there is an id, it comes before any classes.\n      5. Any class name is nonempty."],"^5","~$hickory.hiccup-utils/tag-well-formed?","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^E",23,"^L",["^G",[["^I"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",38,"^P","~$boolean","^D",38,"^R",1,"^S",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Given a hiccup tag element, returns true iff the tag is in 'valid' hiccup\n   format. Which in this function means:\n      1. Tag name is non-empty.\n      2. If there is an id, there is only one.\n      3. If there is an id, it is nonempty.\n      4. If there is an id, it comes before any classes.\n      5. Any class name is nonempty."],"~$tag-name",["^ ","^?",null,"^@",["^ ","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^B",68,"^C",7,"^D",68,"^E",15,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Given a well-formed hiccup tag element, return just the tag name as\n  a string."],"^5","~$hickory.hiccup-utils/tag-name","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^E",15,"^L",["^G",[["^I"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",68,"^P",["^4",["~$any","~$string"]],"^D",68,"^R",1,"^S",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Given a well-formed hiccup tag element, return just the tag name as\n  a string."],"~$split-keep-trailing-empty",["^ ","^?",null,"^@",["^ ","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^B",30,"^C",8,"^D",30,"^E",33,"~:private",true,"^F",["^G",["^H",["^G",[["~$s","~$re"]]]]],"^J","clojure.string/split is a wrapper on java.lang.String/split with the limit\n   parameter equal to 0, which keeps leading empty strings, but discards\n   trailing empty strings. This makes no sense, so we have to write our own\n   to keep the trailing empty strings."],"^10",true,"^5","~$hickory.hiccup-utils/split-keep-trailing-empty","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^E",33,"^L",["^G",[["~$s","^11"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",30,"^P",["^4",[null,"^Y"]],"^D",30,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["~$s","^11"]]]]],"^J","clojure.string/split is a wrapper on java.lang.String/split with the limit\n   parameter equal to 0, which keeps leading empty strings, but discards\n   trailing empty strings. This makes no sense, so we have to write our own\n   to keep the trailing empty strings."],"~$normalize-element",["^ ","^?",null,"^@",["^ ","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^B",148,"^C",8,"^D",148,"^E",25,"^10",true,"^F",["^G",["^H",["^G",[["~$hiccup-form"]]]]],"^J","Given a well-formed hiccup form, ensure that it is in the form\n     [tag attributes content1 ... contentN].\n   That is, an unadorned tag name (keyword, lowercase), all attributes in the\n   attribute map in the second element, and then any children. Note that this\n   does not happen recursively; content is not modified."],"^10",true,"^5","~$hickory.hiccup-utils/normalize-element","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^E",25,"^L",["^G",[["^14"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",148,"^P","^Y","^D",148,"^R",1,"^S",true,"^F",["^G",["^H",["^G",[["^14"]]]]],"^J","Given a well-formed hiccup form, ensure that it is in the form\n     [tag attributes content1 ... contentN].\n   That is, an unadorned tag name (keyword, lowercase), all attributes in the\n   attribute map in the second element, and then any children. Note that this\n   does not happen recursively; content is not modified."],"~$expand-content-seqs",["^ ","^?",null,"^@",["^ ","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^B",121,"^C",8,"^D",121,"^E",27,"^10",true,"^F",["^G",["^H",["^G",[["~$content"]]]]],"^J","Given a sequence of hiccup forms, presumably the content forms of another\n   hiccup element, return a new sequence with any sequence elements expanded\n   into the main sequence. This logic does not apply recursively, so sequences\n   inside sequences won't be expanded out. Also note that this really only\n   applies to sequences; things that seq? returns true on. So this excludes\n   vectors.\n     (expand-content-seqs [1 '(2 3) (for [x [1 2 3]] (* x 2)) [5]])\n     ==> (1 2 3 2 4 6 [5])"],"^10",true,"^5","~$hickory.hiccup-utils/expand-content-seqs","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^E",27,"^L",["^G",[["^17"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",121,"^P","^Q","^D",121,"^R",1,"^S",true,"^F",["^G",["^H",["^G",[["^17"]]]]],"^J","Given a sequence of hiccup forms, presumably the content forms of another\n   hiccup element, return a new sequence with any sequence elements expanded\n   into the main sequence. This logic does not apply recursively, so sequences\n   inside sequences won't be expanded out. Also note that this really only\n   applies to sequences; things that seq? returns true on. So this excludes\n   vectors.\n     (expand-content-seqs [1 '(2 3) (for [x [1 2 3]] (* x 2)) [5]])\n     ==> (1 2 3 2 4 6 [5])"],"~$id",["^ ","^?",null,"^@",["^ ","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^B",108,"^C",7,"^D",108,"^E",9,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Given a well-formed hiccup tag element, return a string containing\n   the id, or nil if there isn't one."],"^5","~$hickory.hiccup-utils/id","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^E",9,"^L",["^G",[["^I"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",108,"^P",["^4",["^Y","~$clj-nil"]],"^D",108,"^R",1,"^S",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^J","Given a well-formed hiccup tag element, return a string containing\n   the id, or nil if there isn't one."],"~$index-of",["^ ","^?",null,"^@",["^ ","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^B",22,"^C",8,"^D",22,"^E",16,"^10",true,"^F",["^G",["^H",["^G",[["~$s","~$c"],["~$s","~$c","~$idx"]]]]],"~:top-fn",["^ ","^O",false,"~:fixed-arity",3,"^R",3,"^L",[["~$s","~$c"],["~$s","~$c","^1="]],"^F",["^G",[["~$s","~$c"],["~$s","~$c","^1="]]],"^N",["^G",[null,null]]]],"^10",true,"^5","~$hickory.hiccup-utils/index-of","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^E",16,"^1>",["^ ","^O",false,"^1?",3,"^R",3,"^L",[["~$s","~$c"],["~$s","~$c","^1="]],"^F",["^G",[["~$s","~$c"],["~$s","~$c","^1="]]],"^N",["^G",[null,null]]],"^L",[["~$s","~$c"],["~$s","~$c","^1="]],"^M",null,"^1?",3,"^N",["^G",[null,null]],"^C",1,"^O",false,"~:methods",[["^ ","^1?",2,"^O",false,"~:tag","^Y"],["^ ","^1?",3,"^O",false,"^1B","^Y"]],"^B",22,"^D",22,"^R",3,"^S",true,"^F",["^G",[["~$s","~$c"],["~$s","~$c","^1="]]]],"~$normalize-form",["^ ","^?",null,"^@",["^ ","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^B",174,"^C",7,"^D",174,"^E",21,"^F",["^G",["^H",["^G",[["~$form"]]]]],"^J","Given a well-formed hiccup form, recursively normalizes it, so that it and\n   all children elements will also be normalized. A normalized form is in the\n   form\n     [tag attributes content1 ... contentN].\n   That is, an unadorned tag name (keyword, lowercase), all attributes in the\n   attribute map in the second element, and then any children. Any content\n   that is a sequence is also expanded out into the main sequence of content\n   items."],"^5","~$hickory.hiccup-utils/normalize-form","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^E",21,"^L",["^G",[["^1D"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",174,"^P",["^4",["^Y","^Z"]],"^D",174,"^R",1,"^S",true,"^F",["^G",["^H",["^G",[["^1D"]]]]],"^J","Given a well-formed hiccup form, recursively normalizes it, so that it and\n   all children elements will also be normalized. A normalized form is in the\n   form\n     [tag attributes content1 ... contentN].\n   That is, an unadorned tag name (keyword, lowercase), all attributes in the\n   attribute map in the second element, and then any children. Any content\n   that is a sequence is also expanded out into the main sequence of content\n   items."],"~$first-idx",["^ ","^?",null,"^@",["^ ","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^B",5,"^C",8,"^D",5,"^E",17,"^10",true,"^F",["^G",["^H",["^G",[["~$a","~$b"]]]]],"^J","Given two possible indexes, returns the lesser that is not -1. If both\n   are -1, then -1 is returned. Useful for searching strings for multiple\n   markers, as many routines will return -1 for not found.\n\n   Examples: (first-idx -1 -1) => -1\n             (first-idx -1 2) => 2\n             (first-idx 5 -1) => 5\n             (first-idx 5 3) => 3"],"^10",true,"^5","~$hickory.hiccup-utils/first-idx","^A","/home/ulli/.cljs/.aot_cache/1.10.866/C2FE1BC/hickory/hiccup_utils.cljc","^E",17,"^L",["^G",[["~$a","~$b"]]],"^M",null,"^N",["^G",[null,null]],"^C",1,"^O",false,"^B",5,"^P",["^4",[null,"^Y"]],"^D",5,"^R",2,"^S",true,"^F",["^G",["^H",["^G",[["~$a","~$b"]]]]],"^J","Given two possible indexes, returns the lesser that is not -1. If both\n   are -1, then -1 is returned. Useful for searching strings for multiple\n   markers, as many routines will return -1 for not found.\n\n   Examples: (first-idx -1 -1) => -1\n             (first-idx -1 2) => 2\n             (first-idx 5 -1) => 5\n             (first-idx 5 3) => 3"]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:id","~:class"]],"~:order",["^1L","^1M"]],"^J","Utilities for working with hiccup forms."]